from dataclasses import dataclass, field
from typing import List, Optional, Tuple
from src.models.loads import RadialForce, Torque
from src.models.components import Component, Bearing, PowerTransmissionComponent, SpurGear, Pulley

@dataclass
class StressFeature:
    """Base class for geometric features causing stress concentration."""
    description: str = "General Feature"
    # User inputs these manually for now as agreed
    kf_bending: float = 1.0 
    kf_torsion: float = 1.0

@dataclass
class Fillet(StressFeature):
    """Shoulder fillet radius."""
    radius: float = 1.0 # mm
    description: str = "Shoulder Fillet"

@dataclass
class Keyway(StressFeature):
    """Keyway for transmitting torque."""
    type: str = "Profile" # 'Profile' or 'SledRunner'
    description: str = "Keyway"

@dataclass
class Groove(StressFeature):
    """Groove for retaining rings."""
    width: float = 1.1 # mm
    depth: float = 0.5 # mm
    description: str = "Retaining Ring Groove"

@dataclass
class ShaftNode:
    """Represents a point of interest on the shaft."""
    position: float # mm
    diameter_left: float # mm
    diameter_right: float # mm
    element: Optional[Component] = None
    stress_concentration: Optional[StressFeature] = None

    @property
    def is_shoulder(self) -> bool:
        return self.diameter_left != self.diameter_right

@dataclass
class ShaftSegment:
    """Represents the cylindrical segment between two nodes."""
    start_node: ShaftNode
    end_node: ShaftNode
    
    @property
    def length(self) -> float:
        return self.end_node.position - self.start_node.position
    
    @property
    def diameter(self) -> float:
        # Assuming diameter is constant in segment for now, taking check from start node right
        return self.start_node.diameter_right

class Shaft:
    """Manager class for the entire shaft assembly."""
    def __init__(self):
        self.nodes: List[ShaftNode] = []
        self.material: dict = {} # Placeholder for material
        
        # Load storage
        # We store them separately for now, but they should logically link to positions (nodes)
        self.forces: List = [] 
        self.torques: List = []

    def add_node(self, position: float, diameter_left: float = None, diameter_right: float = None, element: Optional[Component] = None):
        """Adds a node to the shaft and keeps nodes sorted by position."""
        
        # 1. Check for existing node (fuzzy match)
        existing_node = next((n for n in self.nodes if abs(n.position - position) < 1e-5), None)
        
        if existing_node:
            if diameter_left is not None: existing_node.diameter_left = diameter_left
            if diameter_right is not None: existing_node.diameter_right = diameter_right
            if element is not None: existing_node.element = element
            return

        # 2. If new node, infer defaults if not provided
        # We need to find where this node sits.
        # It's not in the list yet.
        
        if diameter_left is None or diameter_right is None:
            # Sort current nodes to find neighbors
            # (Nodes list is always sorted, but let's be safe if we insert mid-process)
            current_nodes = sorted(self.nodes, key=lambda n: n.position)
            
            # Find left neighbor
            left_neighbor = None
            for n in current_nodes:
                if n.position < position:
                    left_neighbor = n
                else:
                    break
            
            inferred_diam = 20.0
            if left_neighbor:
                inferred_diam = left_neighbor.diameter_right
            elif current_nodes:
                # No left neighbor, but check right? (start of shaft)
                # If we are inserting before the first node?
                inferred_diam = current_nodes[0].diameter_left
            
            if diameter_left is None: diameter_left = inferred_diam
            if diameter_right is None: diameter_right = inferred_diam

        node = ShaftNode(position, diameter_left, diameter_right, element)
        self.nodes.append(node)
        self.nodes.sort(key=lambda n: n.position)

    def get_segments(self) -> List[ShaftSegment]:
        """Generates segments based on current nodes."""
        segments = []
        if len(self.nodes) < 2:
            return segments
        
        for i in range(len(self.nodes) - 1):
            segments.append(ShaftSegment(self.nodes[i], self.nodes[i+1]))
        return segments
    
    def get_total_length(self) -> float:
        if not self.nodes:
            return 0.0
        return self.nodes[-1].position - self.nodes[0].position
    
    def reset(self):
        """Clears all data."""
        self.nodes = []
        self.forces = []
        self.torques = []

    def get_all_loads(self) -> Tuple[List[RadialForce], List[Torque]]:
        """
        Aggregates manually added loads on the shaft AND loads generated by elements.
        Returns: (all_forces, all_torques)
        """
        all_forces = list(self.forces) # Copy to avoid modifying original list ref if we appended
        all_torques = list(self.torques)
        
        for node in self.nodes:
            if node.element is not None:
                # Synchronize position just in case
                node.element.position = node.position 
                if isinstance(node.element, Component):
                     el_forces, el_torques = node.element.calculate_loads()
                     all_forces.extend(el_forces)
                     all_torques.extend(el_torques)
        
        return all_forces, all_torques
