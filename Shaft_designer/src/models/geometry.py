from dataclasses import dataclass, field
from typing import List, Optional, Tuple
from src.models.loads import RadialForce, Torque

@dataclass
class MachineElement:
    """Base class for elements attached to the shaft (Gears, Bearings, etc)."""
    name: str = "Element"

@dataclass
class Bearing(MachineElement):
    """Represents a bearing support."""
    type: str = "Ball" # Propriedade simplificada por enquanto
    width: float = 20.0 # mm
    fixed_axial: bool = False

@dataclass
class PowerTransmissionElement(MachineElement):
    """Base class for power transmission elements (Gears, Pulleys)."""
    # Placeholder for future: power: float = 0.0, rpm: float = 0.0
    # For now, we store manually assigned loads that this element causes.
    manual_forces: List[RadialForce] = field(default_factory=list)
    manual_torques: List[Torque] = field(default_factory=list)

    def calculate_loads(self, position: float) -> Tuple[List[RadialForce], List[Torque]]:
        """
        Returns the loads generated by this element.
        In the future, this will use P, n, d, etc. 
        For now, it returns the manually assigned vectors.
        We update the position of these loads to match the element's position.
        """
        # Ensure position is updated
        for f in self.manual_forces:
            f.position = position
        for t in self.manual_torques:
            t.position = position
        return self.manual_forces, self.manual_torques

@dataclass
class SpurGear(PowerTransmissionElement):
    """Spur Gear functionality."""
    diameter: float = 100.0 # mm, Pitch Diameter
    width: float = 30.0 # mm, Face Width
    pressure_angle: float = 20.0 # degrees
    contact_angle: float = 0.0 # degrees, 0 = Right, 90 = Top

    def calculate_loads(self, position: float) -> Tuple[List[RadialForce], List[Torque]]:
        """
        Calculates Torque automatically from manual forces.
        T = F_tangential * Radius
        Radius vector R = (d/2 * cos(theta), d/2 * sin(theta))
        Force vector F = (Fy, Fz) (assuming Fy=Vertical, Fz=Horizontal) -- Wait, loads.py defines Fy(Vert), Fz(Horiz).
        Let's verify coordinate system.
        Loads.py: 
             fy = mag * cos(angle)
             fz = mag * sin(angle)
             Wait, usually 0 deg is X axis? In YZ Plane:
             Force angle 0 is along Y? Or Z?
             Loads.py says:
                fy = mag * cos(radians(angle))
                fz = mag * sin(radians(angle))
             If angle=0, fy=mag, fz=0. So 0 deg is Vertical (+Y).
             If angle=90, fy=0, fz=mag. So 90 deg is Horizontal (+Z).
        
        Contact Angle theta:
           0 deg (Right) -> +Z axis.
           90 deg (Top) -> +Y axis.
           
           If contact is at Right (+Z), R is along +Z.
           Tangential force is Vertical (+Y).
           If we apply Force F.
           Torque T = R x F (Cross product).
           R = (0, d/2) in YZ? No.
           Let's standard vector Cross Product in 2D (YZ plane):
           T_x = R_y * F_z - R_z * F_y
           
           R_y = (d/2) * cos(contact_angle_from_vertical_Y)?
           If theta=0 is Right (+Z), theta=90 is Top (+Y).
           Relation to Y(+UP):
             Top (90) -> Y axis.
             Right (0) -> Z axis.
           So:
             R_z = (d/2) * cos(theta_rad)  (Close to 0deg -> 1 -> Z)
             R_y = (d/2) * sin(theta_rad)  (Close to 90deg -> 1 -> Y)
             
           T_x = R_y * F_z - R_z * F_y
               = (d/2 * sin(theta)) * F_z - (d/2 * cos(theta)) * F_y
           
        We summon manual forces to get Total Fy, Total Fz.
        """
        import math
        
        # Update position for manual forces
        for f in self.manual_forces:
            f.position = position
            
        # Sum forces
        total_fy = sum(f.fy for f in self.manual_forces)
        total_fz = sum(f.fz for f in self.manual_forces)
        
        d_meters = self.diameter / 1000.0
        radius = d_meters / 2.0
        
        # Theta: User input in degrees. 0=Right(+Z), 90=Top(+Y)?
        # Let's align with user request implication "0 is applied tangent... horizontal to the right".
        # Valid interpretation: Contact point is at 0 degrees.
        theta_rad = math.radians(self.contact_angle)
        
        # R vector components
        # If 0 is Right (+Z), 90 is Top (+Y).
        # Rz = R * cos(theta)
        # Ry = R * sin(theta) 
        rz = radius * math.cos(theta_rad)
        ry = radius * math.sin(theta_rad)
        
        # Torque = Ry*Fz - Rz*Fy (Result vector along X)
        torque_val = ry * total_fz - rz * total_fy
        
        calc_torque = Torque(magnitude=torque_val, position=position)
        
        return self.manual_forces, [calc_torque]

@dataclass
class Pulley(PowerTransmissionElement):
    """Pulley functionality."""
    diameter: float = 100.0 # mm
    width: float = 30.0 # mm
    tension_ratio: float = 3.0 # T1/T2 (Example default)

@dataclass
class StressFeature:
    """Base class for geometric features causing stress concentration."""
    description: str = "General Feature"
    # User inputs these manually for now as agreed
    kf_bending: float = 1.0 
    kf_torsion: float = 1.0

@dataclass
class Fillet(StressFeature):
    """Shoulder fillet radius."""
    radius: float = 1.0 # mm
    description: str = "Shoulder Fillet"

@dataclass
class Keyway(StressFeature):
    """Keyway for transmitting torque."""
    type: str = "Profile" # 'Profile' or 'SledRunner'
    description: str = "Keyway"

@dataclass
class Groove(StressFeature):
    """Groove for retaining rings."""
    width: float = 1.1 # mm
    depth: float = 0.5 # mm
    description: str = "Retaining Ring Groove"

@dataclass
class ShaftNode:
    """Represents a point of interest on the shaft."""
    position: float # mm
    diameter_left: float # mm
    diameter_right: float # mm
    element: Optional[MachineElement] = None
    stress_concentration: Optional[StressFeature] = None

    @property
    def is_shoulder(self) -> bool:
        return self.diameter_left != self.diameter_right

@dataclass
class ShaftSegment:
    """Represents the cylindrical segment between two nodes."""
    start_node: ShaftNode
    end_node: ShaftNode
    
    @property
    def length(self) -> float:
        return self.end_node.position - self.start_node.position
    
    @property
    def diameter(self) -> float:
        # Assuming diameter is constant in segment for now, taking check from start node right
        return self.start_node.diameter_right

class Shaft:
    """Manager class for the entire shaft assembly."""
    def __init__(self):
        self.nodes: List[ShaftNode] = []
        self.material: dict = {} # Placeholder for material
        
        # Load storage
        # We store them separately for now, but they should logically link to positions (nodes)
        self.forces: List = [] 
        self.torques: List = []

    def add_node(self, position: float, diameter_left: float = None, diameter_right: float = None, element: Optional[MachineElement] = None):
        """Adds a node to the shaft and keeps nodes sorted by position."""
        
        # If node exists at position, update it? Or error?
        # For simplicity, if close enough, update.
        existing_node = next((n for n in self.nodes if abs(n.position - position) < 1e-5), None)
        
        if existing_node:
            if diameter_left is not None: existing_node.diameter_left = diameter_left
            if diameter_right is not None: existing_node.diameter_right = diameter_right
            if element is not None: existing_node.element = element
            return

        # Infer defaults if new
        if not self.nodes:
            if diameter_left is None: diameter_left = 20.0
            if diameter_right is None: diameter_right = 20.0
        else:
            # Find nearest neighbors to infer defaults if needed
            pass
            # For this MVP, if None, we might copy neighbor or default. 
            # But let's assume UI provides valid data or we explicitly set it.
            if diameter_left is None: diameter_left = 20.0
            if diameter_right is None: diameter_right = 20.0

        node = ShaftNode(position, diameter_left, diameter_right, element)
        self.nodes.append(node)
        self.nodes.sort(key=lambda n: n.position)

    def get_segments(self) -> List[ShaftSegment]:
        """Generates segments based on current nodes."""
        segments = []
        if len(self.nodes) < 2:
            return segments
        
        for i in range(len(self.nodes) - 1):
            segments.append(ShaftSegment(self.nodes[i], self.nodes[i+1]))
        return segments
    
    def get_total_length(self) -> float:
        if not self.nodes:
            return 0.0
        return self.nodes[-1].position - self.nodes[0].position
    
    def reset(self):
        """Clears all data."""
        self.nodes = []
        self.forces = []
        self.torques = []

    def get_all_loads(self) -> Tuple[List[RadialForce], List[Torque]]:
        """
        Aggregates manually added loads on the shaft AND loads generated by elements.
        Returns: (all_forces, all_torques)
        """
        all_forces = list(self.forces) # Copy to avoid modifying original list ref if we appended
        all_torques = list(self.torques)
        
        for node in self.nodes:
            if isinstance(node.element, PowerTransmissionElement):
                el_forces, el_torques = node.element.calculate_loads(node.position)
                all_forces.extend(el_forces)
                all_torques.extend(el_torques)
        
        return all_forces, all_torques
