from dataclasses import dataclass, field
from typing import List, Tuple, Optional
import math
from src.models.loads import RadialForce, Torque

@dataclass
class Component:
    """Base class for shaft components."""
    name: str = "Component"
    position: float = 0.0 # mm (will be synced with Node)
    
    # Generic manual loads applied to this component
    manual_forces: List[RadialForce] = field(default_factory=list)
    manual_torques: List[Torque] = field(default_factory=list)
    
    def calculate_loads(self) -> Tuple[List[RadialForce], List[Torque]]:
        """Returns the loads generated by this component (base implementation returns manual only)."""
        return list(self.manual_forces), list(self.manual_torques)

@dataclass
class Bearing(Component):
    """Represents a bearing support."""
    type: str = "Ball" # Propriedade simplificada por enquanto
    width: float = 20.0 # mm
    fixed_axial: bool = False

@dataclass
class PowerTransmissionComponent(Component):
    """Base class for components transmitting power."""
    power: float = 0.0 # kW
    rpm: float = 0.0 # rev/min
    efficiency: float = 1.0 # 0.0 to 1.0 (Not used in load calc yet, but good for chain)

    @property
    def torque_mean(self) -> float:
        """Calculates mean torque from Power and RPM. Returns N.m."""
        if self.rpm == 0:
            return 0.0
        # Power in Watts = kW * 1000
        # T = P / w
        # w = rpm * 2pi / 60
        # T = (P*1000) / (rpm * 2pi / 60) = 9549.296 * P / rpm
        # Common approx: 9550 * P_kw / n
        return 9550.0 * self.power / self.rpm
    
    def calculate_loads(self) -> Tuple[List[RadialForce], List[Torque]]:
        # This will be overridden by subclasses, but they should call simple super() or handle manual mix manually
        # Since subclasses have specific logic, they will implementation full logic and append manual
        return super().calculate_loads()

@dataclass
class SpurGear(PowerTransmissionComponent):
    """
    Spur Gear Component.
    Generates Tangential and Radial forces based on Power/RPM or manual Torque.
    """
    diameter: float = 100.0 # mm (Pitch Diameter)
    pressure_angle: float = 20.0 # degrees
    contact_angle: float = 0.0 # degrees ("mesh" angle, 0=Right? User convention)
    
    # Optional override if user wants to specify torque directly instead of P/n
    manual_torque: Optional[float] = None 

    def calculate_loads(self) -> Tuple[List[RadialForce], List[Torque]]:
        # 1. Start with manual loads accessible on base
        forces = list(self.manual_forces)
        torques = list(self.manual_torques)
        
        # 2. Add Geared Loads
        T = self.torque_mean
        if self.manual_torque is not None:
            T = self.manual_torque
            
        if T != 0:
            d_meters = self.diameter / 1000.0
            r_meters = d_meters / 2.0
            
            # Forces
            # Ft = Torque / Radius
            Ft = T / r_meters
            
            # Fr = Ft * tan(phi)
            Fr = Ft * math.tan(math.radians(self.pressure_angle))
            
            # Total Transverse Force
            F_transverse = math.sqrt(Ft**2 + Fr**2)
            
            rf = RadialForce(
                magnitude=F_transverse, 
                angle=self.contact_angle, 
                position=self.position
            )
            
            # Torque
            tq = Torque(mean=T, position=self.position)
            
            forces.append(rf)
            torques.append(tq)
        
        return forces, torques

@dataclass
class Pulley(PowerTransmissionComponent):
    """
    V-Belt or Flat Belt Pulley.
    Generates forces based on sheath tension.
    """
    diameter: float = 100.0 # mm
    preload_factor: float = 3.0 # Ratio F1/F2 (Tight/Slack)
    wrap_angle: float = 180.0 # degrees (Not strictly used in basic F1/F2 ratio model but good context)
    belt_angle: float = 90.0 # Direction of the belt pull (0 = Right, 90 = Up)

    def calculate_loads(self) -> Tuple[List[RadialForce], List[Torque]]:
        forces = list(self.manual_forces)
        torques = list(self.manual_torques)

        T = self.torque_mean
        if T != 0:
            d_meters = self.diameter / 1000.0
            r_meters = d_meters / 2.0
            
            # Net Driving Force F_net = F1 - F2 = T / r
            F_net = T / r_meters
            
            # Relation: F1 / F2 = C (preload_factor)
            # F1 = C * F2
            # C*F2 - F2 = F_net => F2(C - 1) = F_net => F2 = F_net / (C - 1)
            
            if self.preload_factor <= 1.0:
                F2 = F_net # Fallback
            else:
                F2 = F_net / (self.preload_factor - 1.0)
                
            F1 = F_net + F2
            
            # Total Shaft Load (Bending) = F1 + F2
            F_bending_mag = F1 + F2
            
            rf = RadialForce(
                magnitude=F_bending_mag,
                angle=self.belt_angle,
                position=self.position
            )
            
            tq = Torque(mean=T, position=self.position)
            
            forces.append(rf)
            torques.append(tq)
            
        return forces, torques
